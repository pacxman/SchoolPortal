"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const http_1 = require("http");
const stream_1 = require("stream");
const busboy_1 = __importDefault(require("busboy"));
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const onFile_1 = __importDefault(require("./listener/onFile"));
const onField_1 = __importDefault(require("./listener/onField"));
const onFilesLimit_1 = __importDefault(require("./listener/onFilesLimit"));
const onFieldsLimit_1 = __importDefault(require("./listener/onFieldsLimit"));
const onPartsLimit_1 = __importDefault(require("./listener/onPartsLimit"));
const isPlainObject_1 = __importDefault(require("./util/isPlainObject"));
const mapListeners_1 = __importDefault(require("./util/mapListeners"));
const isAsyncIterable_1 = require("./util/isAsyncIterable");
const BodyEntries_1 = require("./BodyEntries");
const initializers = {
    onFile: onFile_1.default,
    onField: onField_1.default,
    onFilesLimit: onFilesLimit_1.default,
    onFieldsLimit: onFieldsLimit_1.default,
    onPartsLimit: onPartsLimit_1.default
};
const defaults = {
    castTypes: true
};
/**
 * Parses `multipart/form-data` body and returns an object with the data of that body
 *
 * @param source HTTP IncomingMessage object
 * @param options Parser options
 *
 * Simplest usage example:
 *
 * ```js
 * import {createServer} from "http"
 * import {parse} from "then-busboy"
 *
 * const handler = (req, res) => parse(req)
 *   .then(async body => {
 *     const result = []
 *
 *     for (const [path, value] of body) {
 *       result.push([path, isFile(value) ? await value.text() : value])
 *     }
 *
 *     res.setHeader("Content-Type", "application/json")
 *     res.end(JSON.stringify(Body.json(result)))
 *   })
 *   .catch(error => {
 *     res.statusCode = error.status || 500
 *     res.end(error.message)
 *   })
 *
 * createServer(handler)
 *   .listen(2319, () => console.log("Server started on http://localhost:2319"))
 * ```
 */
const parse = (
// TODO: I use AsyncIterable<Uint8Array | Buffer | string> as the source type for compatibility with NodeJS.ReadableStream.
// TODO: It should be replaced with AsyncIterable<Uint8Array>, when it gets fixed.
source, options = {}) => new Promise((resolve, reject) => {
    let headers;
    let readable;
    if (!(0, isPlainObject_1.default)(options)) {
        throw new TypeError("Expected options argument to be an object.");
    }
    if (source instanceof http_1.IncomingMessage) {
        readable = source;
        headers = source.headers;
    }
    else if ((0, isAsyncIterable_1.isAsyncIterable)(source)) {
        readable = stream_1.Readable.from(source);
        headers = options.headers;
    }
    else {
        throw new TypeError("The source argument must be instance of IncomingMessage or "
            + "an object with callable @@asyncIterator property.");
    }
    const opts = (0, lodash_merge_1.default)({}, defaults, options, { headers });
    const parser = (0, busboy_1.default)(opts);
    const entries = new BodyEntries_1.BodyEntries();
    const listeners = (0, mapListeners_1.default)(initializers, fn => fn(opts, entries));
    function unsubscribe() {
        (0, mapListeners_1.default)(listeners, (fn, name) => parser.off(name, fn));
    }
    function onError(error) {
        unsubscribe();
        reject(error);
    }
    entries.once("finish", body => {
        unsubscribe();
        resolve(body);
    });
    const onBodyRead = () => entries.finish(true);
    (0, mapListeners_1.default)(listeners, (fn, name) => parser.on(name, fn));
    entries.once("error", onError);
    parser
        .once("error", onError)
        .once("close", onBodyRead);
    readable.pipe(parser);
});
exports.parse = parse;
